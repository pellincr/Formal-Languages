#lang racket
(require fsm)
(require test-engine/racket-tests)

; TEMPLATE
; ;f-on-ndfa: ndfa -> ???
; ;Purpose: ???
; (define (f-on-ndfa ndfa)
;   ;INVENTORY
;   ;(sm-getstates ndfa) -> returns the states of the given machine
;   ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
;   ;(sm-getrules ndfa) -> returns the rules of the given machine
;   ;(sm-getstart ndfa) -> returns the start state of the given machine
;   ;(sm-getfinals ndfa) -> returns the final states of the machine
;   ...)

;Prove that a regular language is closed under Prefix

;NDFA EXAMPLES
(define KLEENESTAR-abUaba
  (make-ndfa '(Q-0 Q-1 Q-2 Q-3 Q-4 Q-5)
             '(a b)
             'Q-0
             '(Q-0)
             `((Q-0 a Q-1)
               (Q-1 b Q-2)
               (Q-2 a Q-3)
               (Q-3 ,EMP Q-0)
               (Q-0 a Q-4)
               (Q-4 b Q-5)
               (Q-5 ,EMP Q-0))))



;Step 1: get the reachable states from the given dfa
;Step 2: filter out any reachable states that do not have a path to the final state(s)
;Step 3: This list of states is now the new machines list of final states

;accept-prefixes: ndfa -> ndfa
;Purpose: to build an dfa that accepts all Prefixs of the initial dfa
(define (accept-prefixes ndfa)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  (let (;The list of all states that have a path to the final state(s)
        (pathable-states (path-to-finish ndfa '((sm-getstartndfa))))
        ;The list of all reachable states
        (reachable-states (get-reachable ndfa '())))
    (make-ndfa (sm-getstates ndfa)
               (sm-getalphabet ndfa)
               (sm-getstart ndfa)
               (filter (lambda (x) (member x pathable-states)) reachable-states)
               (sm-getrules ndfa))))

;get-reachable: ndfa accum-> list-of-states
;Purpose: to return the list of reachable states of te given ndfa using breath-first-search
;ACCUM INV: the accumulator is all of the states that have been reached so far
(define (get-reachable ndfa reached)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  (cond [])
  )


;path-to-finish: ndfa accum-> list-of-states
;Purpose: returns all possible states that can reach the final state(s)
;ACCUM INV:
(define (path-to-finish ndfa valid-states)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  )


;generate-neighbors: symbol ndfa -> (listof-ndfa)
;Purpose: to generate the neighbors of the given symbol in the given ndfa
(define (generate-neighbors state ndfa)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  )

(test)
