#lang racket
(require fsm)
(require test-engine/racket-tests)

; TEMPLATE
; ;f-on-ndfa: ndfa -> ???
; ;Purpose: ???
; (define (f-on-ndfa ndfa)
;   ;INVENTORY
;   ;(sm-getstates ndfa) -> returns the states of the given machine
;   ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
;   ;(sm-getrules ndfa) -> returns the rules of the given machine
;   ;(sm-getstart ndfa) -> returns the start state of the given machine
;   ;(sm-getfinals ndfa) -> returns the final states of the machine
;   ...)

;Prove that a regular language is closed under Prefix

;NDFA EXAMPLES
(define KLEENESTAR-abUaba
  (make-ndfa '(Q-0 Q-1 Q-2 Q-3 Q-4 Q-5)
             '(a b)
             'Q-0
             '(Q-0)
             `((Q-0 a Q-1)
               (Q-1 b Q-2)
               (Q-2 a Q-3)
               (Q-3 ,EMP Q-0)
               (Q-0 a Q-4)
               (Q-4 b Q-5)
               (Q-5 ,EMP Q-0))))



;Step 1: get the reachable states from the given dfa
;Step 2: filter out any reachable states that do not have a path to the final state(s)
;Step 3: This list of states is now the new machines list of final states

;accept-prefixes: ndfa -> ndfa
;Purpose: to build an dfa that accepts all Prefixs of the initial dfa
(define (accept-prefixes ndfa)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  (let (;The list of all states that have a path to the final state(s)
        (pathable-states (path-to-finish ndfa (sm-getfinals ndfa)))
        ;The list of all reachable states
        (reachable-states (get-reachable ndfa)))
    (make-ndfa (sm-getstates ndfa)
               (sm-getalphabet ndfa)
               (sm-getstart ndfa)
               (filter (lambda (x) (member x pathable-states)) reachable-states)
               (sm-getrules ndfa))))



;prefix-check: ndfa word -> boolean
;Purpose: to determine if all prefixes of the given word are accepted
(define (prefix-check ndfa word)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  (cond [(and (eq? word "") (eq? (sm-apply ndfa word) 'accept)) #t]
        [else (and (eq? (sm-apply ndfa word) 'accept) (prefix-check ndfa (substring word 1)))]))


;get-reachable: ndfa-> list-of-states
;Purpose: to return the list of reachable states of te given ndfa using breath-first-search
;ACCUM INV: the accumulator is all of the states that have been reached so far
(define (get-reachable ndfa)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  (letrec ;reachable: (listof states) (listof states) ->(listof states)
      ;Purpose: to process through the ndfa and return the reachable states
      ;ACCUM INV: the states that have been reached so far
      ((reachable (lambda(states-left reached)
       (cond [(null? states-left) reached]
             [else
              (letrec ((neighbors (filter (lambda (x) (not (member x reached))) (generate-neighbors (sm-getrules ndfa) (car states-left)))))
                (reachable (append neighbors (cdr states-left)) (cons (car states-left) reached)))]))))
    (reachable '((sm-getstart ndfa)) '())))


;path-to-finish: ndfa-> list-of-states
;Purpose: returns all possible states that can reach the final state(s)
;ACCUM INV:
(define (path-to-finish ndfa final-states)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  (letrec;valid: (listof states) (listof states) -> (listof states)
        ;Purpose: to return the list of states the reach the given final state
        ;ACCUM INV: the states that can reach the final state
        ((valid (lambda (states-left current-valid-states)
          ;INVENTORY
          ;(sm-getstates ndfa) -> returns the states of the given machine
          ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
          ;(sm-getrules ndfa) -> returns the rules of the given machine
          ;(sm-getstart ndfa) -> returns the start state of the given machine
          ;(sm-getfinals ndfa) -> returns the final states of the machine
          (cond [(null? states-left) current-valid-states]
                [else (letrec (;neighbors: the list of neighbors of the first of states-left without any that already
                            ;exist in the accumulator
                            (neighbors (filter (lambda (x) (not (member x current-valid-states)))
                                               (generate-neighbors (sm-getrules ndfa) (car states-left)))))
                      (valid (append neighbors (cdr states-left)) (cons (car states-left) current-valid-states)))]))))
    (cond [(null? (cdr final-states)) (valid '((car final-states)) '())]
          [else (append (valid '((car final-states)) '()) (path-to-finish ndfa (cdr final-states)))])))


;generate-neighbors: (listof rules) symbol -> (listof-ndfa)
;Purpose: to generate the neighbors of the given symbol in the given ndfa
(define (generate-neighbors rules state)
  ;INVENTORY
  ;(sm-getstates ndfa) -> returns the states of the given machine
  ;(sm-getalphabet ndfa) -> returns the alphabet of the given machine
  ;(sm-getrules ndfa) -> returns the rules of the given machine
  ;(sm-getstart ndfa) -> returns the start state of the given machine
  ;(sm-getfinals ndfa) -> returns the final states of the machine
  (cond [(null? rules) '()]
        [(eq? (caar rules) state) (cons (caddar rules) (generate-neighbors (cdr rules) state))]
        [else (generate-neighbors (cdr rules) state)]))

(check-expect (generate-neighbors (list '(A a B)
                                        '(A b A)
                                        '(B b A)
                                        '(B a B))
                                  'A)
              '(B A))

(test)
